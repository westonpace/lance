// use std::sync::Arc;

// use arrow_array::{
//     FixedSizeListArray, Float32Array, RecordBatch, RecordBatchIterator, RecordBatchReader,
// };
// use arrow_schema::{DataType, Field, Schema};

// /// This goal of this function is to generate data that behaves in a very deterministic way so that
// /// we can evaluate the correctness of an IVF_PQ implementation.  Currently it is restricted to the
// /// L2 distance metric.
// ///
// /// First, we generate a set of centroids.  These are generated randomly but we ensure that is
// /// sufficient distance between each of the centroids.
// ///
// /// Then, we generate 256 vectors per centroid.  Each vector is generated by making a line by
// /// adding / subtracting [1,1,1...,1] (with the centroid in the middle)
// ///
// /// The trained result should have our generated centroids (without these centroids actually being
// /// a part of the input data) and the PQ codes for every data point should be identical and, given
// /// any three data points a, b, and c that are in the same centroid then the distance between a and
// /// b should be different than the distance between a and c.
// struct WellKnownIvfPqData {
//     dim: u32,
//     num_centroids: u32,
//     centroids: Option<Float32Array>,
//     vectors: Option<Float32Array>,
// }

// impl WellKnownIvfPqData {
//     // Right now we are assuming 8-bit codes
//     const VALS_PER_CODE: u32 = 256;
//     const COLUMN: &'static str = "vector";

//     fn new(dim: u32, num_centroids: u32) -> Self {
//         Self {
//             dim,
//             num_centroids,
//             centroids: None,
//             vectors: None,
//         }
//     }

//     fn distance_between_points(&self) -> f32 {
//         (self.dim as f32).sqrt()
//     }

//     fn generate_centroids(&self) -> Float32Array {
//         const MAX_ATTEMPTS: u32 = 10;
//         let distance_needed = self.distance_between_points() * Self::VALS_PER_CODE as f32 * 2_f32;
//         let mut attempts_remaining = MAX_ATTEMPTS;
//         let num_values = self.dim * self.num_centroids;
//         while attempts_remaining > 0 {
//             // Use some biggish numbers to ensure we get the distance we want but make them positive
//             // and not too big for easier debugging.
//             let centroids: Float32Array =
//                 generate_scaled_random_array(num_values as usize, 0_f32, 1000_f32);
//             let mut broken = false;
//             for (index, centroid) in centroids
//                 .values()
//                 .chunks_exact(self.dim as usize)
//                 .enumerate()
//             {
//                 let offset = (index + 1) * self.dim as usize;
//                 let length = centroids.len() - offset;
//                 if length == 0 {
//                     // This will be true for the last item since we ignore comparison with self
//                     continue;
//                 }
//                 let distances = l2_distance_batch(
//                     centroid,
//                     &centroids.values().slice(offset, length),
//                     self.dim as usize,
//                 );
//                 let min_distance = distances
//                     .values()
//                     .iter()
//                     .copied()
//                     .min_by(|a, b| a.total_cmp(b))
//                     .unwrap();
//                 // In theory we could just replace this one vector but, out of laziness, we just retry all of them
//                 if min_distance < distance_needed {
//                     broken = true;
//                     break;
//                 }
//             }
//             if !broken {
//                 return centroids;
//             }
//             attempts_remaining -= 1;
//         }
//         panic!(
//             "Unable to generate centroids with sufficient distance after {} attempts",
//             MAX_ATTEMPTS
//         );
//     }

//     fn get_centroids(&mut self) -> &Float32Array {
//         if self.centroids.is_some() {
//             return self.centroids.as_ref().unwrap();
//         }
//         self.centroids = Some(self.generate_centroids());
//         self.centroids.as_ref().unwrap()
//     }

//     fn get_centroids_as_list_arr(&mut self) -> Arc<FixedSizeListArray> {
//         Arc::new(
//             FixedSizeListArray::try_new_from_values(self.get_centroids().clone(), self.dim as i32)
//                 .unwrap(),
//         )
//     }

//     fn generate_vectors(&mut self) -> Float32Array {
//         let dim = self.dim as usize;
//         let num_centroids = self.num_centroids;
//         let centroids = self.get_centroids();
//         let mut vectors: Vec<f32> =
//             vec![0_f32; Self::VALS_PER_CODE as usize * dim * num_centroids as usize];
//         for (centroid, dst_batch) in centroids
//             .values()
//             .chunks_exact(dim)
//             .zip(vectors.chunks_exact_mut(dim * Self::VALS_PER_CODE as usize))
//         {
//             for (offset, dst) in (-128..0).chain(1..129).zip(dst_batch.chunks_exact_mut(dim)) {
//                 for (cent_val, dst_val) in centroid.iter().zip(dst) {
//                     *dst_val = *cent_val + offset as f32;
//                 }
//             }
//         }
//         Float32Array::from(vectors)
//     }

//     fn get_vectors(&mut self) -> &Float32Array {
//         if self.vectors.is_some() {
//             return self.vectors.as_ref().unwrap();
//         }
//         self.vectors = Some(self.generate_vectors());
//         self.vectors.as_ref().unwrap()
//     }

//     fn get_vector(&mut self, idx: u32) -> Float32Array {
//         let dim = self.dim as usize;
//         let vectors = self.get_vectors();
//         let start = idx as usize * dim;
//         vectors.slice(start, dim)
//     }

//     fn generate_batches(&mut self) -> impl RecordBatchReader + Send + 'static {
//         let dim = self.dim as usize;
//         let vectors_array = self.get_vectors();

//         let schema = Arc::new(Schema::new(vec![Field::new(
//             Self::COLUMN,
//             DataType::FixedSizeList(
//                 Arc::new(Field::new("item", DataType::Float32, true)),
//                 dim as i32,
//             ),
//             true,
//         )]));
//         let array = Arc::new(
//             FixedSizeListArray::try_new_from_values(vectors_array.clone(), dim as i32).unwrap(),
//         );
//         let batch = RecordBatch::try_new(schema.clone(), vec![array.clone()]).unwrap();
//         RecordBatchIterator::new(vec![batch].into_iter().map(Ok), schema.clone())
//     }
// }
